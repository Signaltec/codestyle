# Codestyle / Соглашения по стилю кодирования в Сигналтеке

Цель данного документа описать как нужно и как не нужно писать код. 
В компании Сигналтек используются языки программирования: C++, Javascript, Python, Go.
Несмотря на то, что для каждого языка существуют собственные «хорошие» практики кодирования, мы постарались объединить некоторые общие моменты в этом документе.

Одним способом поддержки управляемости кода является обеспечение его единообразия. Очень важно, чтобы любой программист мог взглянуть на чужой код и быстро в нем разобраться.

Стили принятые для каждого языка:
- C++: (https://google.github.io/styleguide/cppguide.html)[Google C++ Style Guide]  
- Javascript: (https://github.com/Signaltech/sjsg)[Сигналтек Google C++ Style Guide]  
- Python: (https://pep8.ru/doc/pep8/)[PEP8]  
- Go: gofmt

Для начала перечислим некоторые общие принципы, которых стоит придерживаться:

## Принцип DRY (don’t repeat yourself) Не дублируйте код! 
Сле­до­ва­ние прин­ципу про­грам­ми­ро­ва­ния «DRY» поз­во­ляет добиться высо­кой сопро­вож­да­е­мо­сти про­ек­та: про­стоты вне­се­ния изме­не­ний и каче­ствен­ного тестирования.

Не дублируйте код! Не используйте программирование методом «ctrl+c, ctrl+v» внутри кодовой базы. 

Если код не дуб­ли­ру­ет­ся, то для изменения логики достаточно внесения исправлений всего в одном месте и проще тести­ро­вать одну (пусть и более сложную) функцию, а не набор из десятков однотипных.

## Принцип KISS (keep it simple stupid). Делайте всё как можно проще
Используйте бритву Оккама — всё следует упрощать до тех пор, пока это возможно, но не более того.
Помните, основной императив в разработке ПО — управление сложностью. Уменьшайте сложность своих решений. Чем сложнее код, тем более подвержен он ошибкам, тем сложнее он для чтения и поддержки.
Не пишите «хитрый» код. Если код, которые вы пишите «хитрый» для вас, то с большой долей вероятности, 
он будет совершенно непонятен другим разработчикам.

## Принцип YAGNI (you ain’t gonna need it) Принцип «Вам это не понадобится» 
То, что не задумано в системе, не должно появляться в коде. 
Если в системе не предусмотрена абстракция для БД – этой абстракции не должно быть. 
Если вдруг понадобится переехать на другую БД, очевидно, что это повлечет затраты на изменение системы.

Принцип YAGNI похож на DRY — он старается уменьшить сложность. Но DRY призывает разделять систему на компоненты, YAGNI призывает уменьшить количество компонентов.

Принцип YAGNI похож на KISS – он старается делать вещи как можно проще. Но KISS старается искать простые решения, а YAGNI просто не делает никаких решений!

Согласно принципу Парето: ~80% затраченного времени тратится на реализацию 20% функционала системы. Просто найдите то, что необходимо реализовать и реализуйте только это. Не делайте ненужную работу!

## Не заставляйте меня думать!
Не пишите «хитрый» код. Пишите максимально простой, понятный, очевидный код. Если код, который вы пишете не очевиден для вас, то он совершенно непонятен остальным разработчикам. Придерживайтесь принятых соглашений. Пишите комментарии.

## Не оптимизируйте
Не оптимизируйте код. Выполняйте оптимизацию только на конечных этапах проекта.
Оптимизируйте только те участки кода, производительность которых измерена и явно недостаточна в рамках ограничений проекта. 
Проверяйте в профайлере код до и после оптимизации. Не полагайтесь на интуицию. Всегда всё перепроверяйте.

## Будьте последовательны
Согласованность важней персональных предпочтений. Поддерживайте в проектах общий стиль кодирования.
Во многих случаях при кодировании возможны различные варианты реализации, в не зависимости от выбора последовательно придерживайтесь его в рамках всего проекта. Будьте последовательны.

## Принципы наименования
Имена это важно! Стиль имени должен информировать о том с чем мы имеем дело (тип, переменная, функция, константа, макрос и т. д.) без необходимости поиска объявления этой сущности.

### Общие правила
Имена функций, переменных и файлов должны быть описательными, воздерживайтесь от аббревиатур. Типы и переменные должны быть именами существительными, в то время как функции должны быть «командными» глаголами.

### Как именовать
Задавайте описательное имя по возможности, в разумных пределах. 

Хорошо
```
int num_errors;
int num_completed_connections; // Хорошо.
```

Плохо
```
int n; // Плохо - бессмысленное имя.
int nerr; // Плохо - не очевидное сокращение.
int n_comp_conns; // Плохо - не очевидное сокращение.
```

Имена для типов и переменных обычно должны быть существительными, например: FileOpener, num_errors.

Имена функций обычно должны быть императивными (т.е. они должны быть командами), например: OpenFile(), set_num_errors(). 
Исключением являются функции доступа, которые, следует называть так же, как и переменную к которой они открывают доступ (актуально для C++).

### Стили в именах
* camelCase
* PascalCase
* snake_case (underscore)
* kebab-case

### Сокращения
Не используйте сокращения, за исключением случаев, когда они отлично известны за рамками вашего проекта. Например:
```
int wgc_connections; // Плохо! Только ваша группа знает что означает
int pc_reader; // Плохо! Множество вещей может скрываться за сокращением «pc»
int dns_server; // Приемлемо. Аббревиатура DNS хорошо известна

// Никогда не сокращайте выбрасывая буквы:
int error_count; // Хорошо
int error_cnt; // Плохо
int rkchkbks; // Плохо! Хотя, нет, всё-таки плохо
```

### Имена файлов
Имена файлов должны использовать нижний регистр и могут включать подчеркивание (_) или дефис (-). Следуйте соглашениям вашего проекта.
Пример допустимых имен файлов:
```
my_useful_class.cc
my-useful-class.cc
myusefulclass.cc
```
В некоторых случаях в именах файлов допустим camelCase (TODO)

### Имена типов
Имена типов начинаются с заглавной буквы и используют заглавную букву для каждого нового слова без подчеркивания (PascalCase): MyExcitingClass, MyExcitingEnum.
Имена всех типов - классов, структур, typedef-ов и перечислений - используют одно и тоже соглашение по наименованию. Например:
```
// классы и структуры
class UrlTable { …

class UrlTableTester { …

struct UrlTableProperties { …

// typedefs
typedef hash_map<UrlTableProperties *, string> PropertiesMap;

// enums
enum UrlTableErrors { …
```

### Имена Переменных
Для имен переменных, в зависимости от языка, используется разная нотация. 

C++ — имена переменных только нижний регистр с подчеркиванием между словами. Переменные члены классов завершаются подчеркиванием. К примеру:
my_exciting_local_variable, my_exciting_member_variable_.

JS, Python, Go — имена переменных в camelCase, начинаются с буквы в нижнем регистре . Например, myExcitingLocalVariable.

### Глобальные Переменные
Нет особых требований для глобальных переменных, которые должны в любом случае использоваться редко. 
Рассмотрите возможность использования префикса g_ или любого другого маркера для простого отличия их от локальных переменных.

### Имена Функций
Обыкновенные функции используют смешанный регистр; функции доступа соответствуют именам переменных:
MyExcitingFunction(), MyExcitingMethod(), my_exciting_member_variable(), set_my_exciting_member_variable().

Функции следует начинать с заглавной буквы и использовать заглавную букву для каждого нового слова, без подчеркиваний (PascalCase):
```
AddTableEntry()

DeleteUrl()
```

### Имена Перечислений
Для перечисления следует использовать ALL CAPS: ENUM_NAME.

### Использование const
Используйте const везде, где это имеет смысл.

### Порядок объявлений
Внутри каждой части делайте объявления в следующем порядке:
* Typedef и Enum
* Константы
* Конструкторы
* Деструкторы
* Методы, включая статические методы
* Члены данных, включая статические

## Переменные и область видимости
Размещайте переменные функции в минимальной области видимости и инициализируйте их во время объявления. Минимизируйте использование глобальных переменных.

```
int i;
i = 10; // Плохо: инициализация отделена от объявления
int j = 10; // Хорошо: объявление инициализирует переменную
```

Здесь только одно предостережение: если переменная является объектом, тогда его конструктор вызывается каждый раз при входе в область видимости при создании объекта, а его деструктор на выходе.

Неэффективная реализация
```
for (int i = 0; i < 1000000; ++i) {
Foo f; // Конструктор и деструктор будут вызваны 1000000 раз.
  f.DoSomething(i);
}
```

Эффективная реализация
```
Foo f; // Конструктор и деструктор вызываются один раз.
for (int i = 0; i < 1000000; ++i) {
  f.DoSomething(i);
}
```

## Функции

### Порядок параметров в функции
Задавая порядок параметров, располагайте входные параметры перед выходными. Никогда не добавляйте новые параметры в конец только потому, что они новые, размещайте новые входные параметры перед выходными параметрами.


### Размер функции
Пишите короткие специализированные функции.
Если функция превышает 40 строчек, тогда задумайтесь над тем может ли она быть разбита на несколько без вреда для структуры программы.
Даже если ваша длинная функция работает на данный момент безошибочно, через несколько месяцев кто-то может добавить новые функциональные возможности. В результате этого могут появиться трудно определимые ошибки. Создавая свои функции простыми и короткими вы облегчаете другим людям чтение и модификацию вашего кода.

Вы можете встретить длинные и сложные функции при чтении кода. Не бойтесь изменять существующий код: если работать с подобной функцией сложно, ошибки отлаживать тяжело, или вы хотите использовать его часть в нескольких других местах, постарайтесь разбить функцию на более маленькие и управляемые куски.


## Комментарии
Пишите комментарии, но помните: хотя комментарии и очень важны, наилучший код самодокументируем. Не пишите лишних комментариев.
Комментируйте «тонкие места», особенности реализации.

### Стиль комментариев
Используйте // для однострочных и /* */ для многострочных комментариев. 
Будьте последовательны.

### Файловые Комментарии
Каждый файл должен содержать сверху описательный комментарий, следующего вида:
```
/*
Copyright 2019 Сигналтек
Author: Galiev Ildar fake@signaltec.ru
TODO
*/
```

### Комментарии к классу, функции
К каждому определению класса, функции следует добавлять сопроводительный комментарий, описывающий для чего это и как это надлежит использовать.

Не коментируйте очевидное. 
Если ваш язык поддерживает самодокументирование, то комментарии стоит оформлять в соотвествии с правилами самодокументирования.

TODO
```
// Person — человек …
class Person {
  …
};

// Делает человека счастливым
function MakePersonHappy() {
  …
}
```

### Глобальные переменные
Все глобальные переменные следует снабжать комментариями описывающими чем они являются и для чего используются.
```
// Общее число тестов запускаемых в этом регрессивном тесте.
const int kNumTestCases = 6;
```

### Комментарии реализации
Вы должны комментировать запутанные, неочевидные, интересные или важные части вашего кода.

TODO


### Инлайн комментарии
По возможности не используйте инлайн комментарии, пользуйтесь ими, только в случае если их использование лучше помогает чтению кода, чем строчные.

### Что делать нельзя
Никогда не описывайте механику работы кода. Комментируйте только цель кода.

Плохо
```
// Теперь пройдем массив b и удостоверимся что если встретится i, то

// следующий элемент будет i+1.

// константное значение равное 10
```

### Пунктуация, Орфография, Грамматика
Пишите комментарии грамотно.
Обратите внимание на пунктуацию, орфографию и грамматику. Легче читать хорошо написанные комментарии. 

Комментарии, как правило, должны быть написаны как законченные предложения с соответствующими прописными буквами. 

### Комментарии TODO `
Используйте TODO [сделать в будущем] комментарии для временного кода, кратковременного или допустимого, но не идеального решения.
TODO комментарии должный включать строку TODO заглавными буквами. Придерживайтесь данного соглашения.
```
// TODO(@ildarka) изменить это и использовать отношения @ildarka
```

## Форматирование
Стиль кодирования и форматирования довольно произволен, однако проект гораздо легче сопровождать, если каждый использует тот же стиль. Некоторые могут не согласиться с каждым аспектом правил форматирования, и отдельные правила могут потребовать определённого привыкания, но важно, чтобы все участники проекта следовали стилистическим правилам так, чтобы все они могли легко читать и понимать код каждого.

### Длина Строки
Каждая строка текста в вашем коде не должна превышать 150 символов в длину.


### Пробелы или табуляция?
Используйте только пробелы, по 2 на уровень отступа. Настройте свой редактор.

### Объявления и определения функций
Тип возвращаемого значения и параметры, если они умещаются, должны быть на одной строке с именем функции.
```
ReturnType ClassName::FunctionName(Type par_name1, Type par_name2) {
DoSomething();
…
}
```
Несколько пунктов на заметку:
Возвращаемый тип всегда находится на той же самой строке где и имя функции.
Открывающая скобка всегда находится на той же самой строке где и имя функции.
Никогда нет пробелов между именем функции и открывающей скобкой.
Никогда нет пробелов между круглыми скобками и параметрами.
Должен быть пробел между закрывающей круглой скобкой и открывающей фигурной скобкой.

### Вызовы функций
На одной линии, если умещаются; в противном случае, переносите аргументы в скобках.
```
bool retval = DoSomething(argument1, argument2, argument3);

bool retval = DoSomething(averyveryveryverylongargument1,
argument2, argument3);
```

### Условные выражения
Не стоит ставить пробелы внутри скобок. Ключевое слово else должно быть на новой строке.
Есть два приемлемых формата для основных условных выражений. Один включает пробелы между скобками и условием, а другой — нет.
```
if (condition) { // внутри скобок нет пробелов
… // отступ в 2 пробела.
} else { 
// Слово else идёт на той же строке, на которой стоит закрывающая скобка.
…
}
```

Заметьте, что во всех случаях вы должны ставить пробелы между словом if и открывающей скобкой. Также вы должны ставить пробел между закрывающей скобкой и фигурной скобкой, если таковую используете.
Хорошо
```
if (condition) { // Хорошо - верные пробелы после IF и перед {.
```
Плохо
```
if(condition) // Нет пробела после IF.
if (condition){ // Нет пробела перед {.
if(condition){ // Плохо вдвойне.
```

### Циклы и Операторы Выбора
Оператор Switch может использовать скобки для блоков. Пустые тела цикла должны использовать {}.


Пустой цикл должен использовать {} либо continue, но не точку с запятой.
```
while (condition) {
  // Повторить тест до тех пор, пока он вернет результат
}

for (int i = 0; i < kSomeNumber; ++i) {} // Хорошо - пустое тело цикла.

while (condition) continue; // Хорошо - continue означает пустой цикл.

while (condition); // Плохо - выглядит как часть цикла do/while.
```

### Выражения с указателями и ссылками
Не используйте пробел около точки или угловой стрелки. Операции с указателями не должны заканчиваться пробелами.
Хорошо
```
x = *p;

p = &x;

x = r.y;

x = r->y;

char *c;

const string &str;

// Так допустимо - последующий пробел 
char* c; // но помните писать "char* c, *d, *e, …;"!
const string& str;
char * c; // Плохо: пробелы с обеих сторон *
const string & str; // Плохо: пробелы с обеих сторон &
```

Обратите внимание что: отсутствуют пробелы вокруг "." или "->" при доступе к члену.
Операторы указателей не имеют пробелов после * или &.
При объявлении указателей переменных или аргументов вы можете размещать символ * примыкающим или к типу, или к имени переменной:
Следует быть последовательным в каждом файле, так что, при модификации существующего файла, используйте в нем выбранный стиль.

### Логические Выражения

Если ваше логическое выражение длиннее стандартной длины строки, то будьте последовательны в том, как вы разбиваете ее на строки.
В данном примере логический оператор "И" всегда в конце строк:
```
if (this_one_thing > this_other_thing &&

a_third_thing == a_fourth_thing &&

yet_another & last_one) {

…

}
```

### Возвращаемые Значения
Не заключайте возвращаемое выражение в скобки.
Возвращаемые значения не должны иметь скобок:
```
return x; // а не return(x);
```


### Формат Класса
Секции размещаются в порядке public, protected и private, каждая с отступом в один пробел.


Основной формат объявления класса (без использования комментариев, см. "Комментарии к классу" для обсуждения того, какие комментарии необходимы):
```
class MyClass : public OtherClass {

public: // Обратите внимание на отступ в 1 пробел!

MyClass(); // Стандартный 2-х пробельный отступ.

explicit MyClass(int var);

~MyClass() {}

void SomeFunction();

void SomeFunctionThatDoesNothing() {

}

void set_some_var(int var) { some_var_ = var; }

int some_var() const { return some_var_; }

private:

bool SomeInternalFunction();

int some_var_;

int some_other_var_;

DISALLOW_COPY_AND_ASSIGN(MyClass);

};
```

На что обратить внимание:

Имя любого базового класса должно быть в той же строке с именем подкласса и подвержено ограничению 150 символов на строку.

Ключевые слова public:, protected: и private: должны иметь отступ в один пробел.

За исключением первого ключевого слова они должны отделяться пустой строкой. Это правило необязательно для маленьких классов.

Не вставляйте пустую строку после этих ключевых слов.

public секция должна быть первой, затем следует protected и затем private.

Смотрите "Порядок Объявлений" для правил упорядочения объявлений в этих секциях. 



### Форматирование пространств имен

Содержимое пространства имен не требует отступа.
Пространства имен не добавляют еще один уровень отступа. Например:

namespace {
void foo() { // Правильно. Нет дополнительного отступа внутри пространства имени.
…

}

} // namespace

Не используйте отступ внутри пространства имен:

namespace {
// Неправильно. Неправомерно использован отступ.
  void foo() {
…
}
} // namespace

### Горизонтальные пробелы
Использование горизонтальных пробелов зависит от места. Никогда не размещайте пробелы в конце строки.
```
void f(bool b) { // Открывающие скобки всегда должны иметь пробел перед ними.

…

int i = 0; // Точка с запятой обычно не имеет пробела перед ней

int x[] = { 0 }; // Пробелы внутри скобок для инициализации массива

int x[] = {0}; // необязательны. Если вы используете их, размещайте их на обоих сторонах!

// Пробелы вокруг двоеточия при наследовании и в инициализизации

class Foo : public Bar {

public:

// В встроенных функциях размещайте пробелы между скобками

// и собственно кодом функции

Foo(int b) : Bar(), baz_(b) {} // В пустых функциях пробел не нужен

void Reset() { baz_ = 0; } // Пробелы между скобками и реализацией

…
```

Не используйте пробелы в конце строки.

### Циклы и условия
```
if (b) { // Пробел после if

} else { // Пробелы вокруг else

}

while (test) {} // Нет пробела между фигурными скобками

switch (i) {

for (int i = 0; i < 5; ++i) {

switch ( i ) { // Циклы и условия могут содержать пробелы

if ( test ) { // внутри круглых скобок в редких случаях. Будьте последовательны.

for ( int i = 0; i < 5; ++i ) {

for ( ; i < 5 ; ++i) { // Циклы for всегда используют пробел после

… // точки с запятой, и могут иметь пробел перед 

// точкой с запятой.

switch (i) {

case 1: // Нет пробела перед двоеточием в switch case.

…

case 2: break; // Используйте пробел после двоеточия если за ним идет код.

Операторы

x = 0; // Операторы присвоения всегда окружены пробелами

 // them.

x = -5; // Никаких пробелов разбивающих унарные операторы и их

++x; // аргументы.

if (x && !y)

…

v = w * x + y / z; // Бинарные операторы обычно окружены пробелами, 

v = w*x + y/z; // но допустимо убирать пробелы между множителями.

v = w * (x + z); // Круглы скобки не должны иметь пробелов вокруг них.

Шаблоны и приведение типов.

vector<string> x; // Никаких пробелов внутри угловых

y = static_cast<char*>(x); // скобок (< и >), перед <, или между 

// >( при приведении типа.

vector<char *> x; // Пробелы между типом и указателем

// допустимы, но будьте последовательны.

set<list<string> > x; // C++ требует пробела в > >.

set< list<string> > x; // Возможно вставлять 

// пробел в < < для симметрии.
```

### Вертикальные пробелы
Минимизируйте использование вертикальных пробелов
TODO
```
while (condition) {

// Не нужная строка в конце

}

if (condition) {

// Не нужная строка в начале

}

// Можно добавлять пустые строки между if-else блоками

if (condition) {

// Некоторые строки кода слишком маленькие, чтобы их можно было перенести в другую функцию,

// заканчиваются пустой строкой

} else {

// следующий блок кода

}
```

## Существующий код, написанный не по правилам
Вы можете не следовать правилам, если код не соответствует стилю описанном в данном руководстве.
Если редактируете код, старайтесь придерживаться стиля, который использован в этом коде. Если вы сомневаетесь, спросите автора оригинального кода или человека, который отвечает за этот код. Запомните, что целостность кода подразумевает и локальную целостность.


## В заключение
Смысл наличия стилистических правил в том, чтобы иметь привычную терминологию кодирования, чтобы люди могли сосредоточиться на том, что они делают, а не на том, как они это делают. Пишите код для людей. Компьютеру всё равно как написан ваш код.

Будьте последовательным и не забывайте о здравом смысле.


